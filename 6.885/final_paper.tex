\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{listings}

\title{EagerDB:\\
A Predictive Cache Warming Tool\\
6.885 Final Paper
}

\author{
John J. Wang\\
wangjohn@mit.edu\\
}
\date{\today}

\begin{document}
\maketitle

\abstract{
Many applications increase database performance using some form of caching. The majority of cache implementations, however, only increase performance for queries that have been already seen. EagerDB takes this a step farther and provides a predictive cache. It predicts queries that will occur in the future with high probability and automatically loads them into the cache. EagerDB allows the user to manually specify query preloads or automatically parse historical database logs, estimate a Markov model, and preload queries which have high transition probabilities.
}

\section{Introduction}

Most web applications improve database performance by caching -- storing data has has previously been used. Using a cache can dramatically improve database performance when temporal locality is present (i.e. when previously requested data is requested multiple times). Caching has become one of the most fundamental concepts in computer science, and in turn, almost all large technology companies use caches in some form.

However, caches assume that historical data repeats. This assumption does not capture all of the potential performance gains that are possible. In fact, there is quite a large amount of data that exists which can be used to improve performance even further. Since there workflows of users tend to be methodical, the queries that get sent to a database can be predicted. One can then estimate the probability of some query $X$ happening given the current state of the database, and ``preload'' $X$ when it has a high probability of happening.

EagerDB provides a framework for preloading such queries. Developers can manually specify queries to preload or they can use a prediction engine for discovering queries to preload. EagerDB is built as a Ruby gem and can be easily included in a Ruby on Rails web application for easy improvements in database performance. This paper shall outline the design of EagerDB, the reasons for making particular design decisions, and the results of benchmark tests.

\section{Background}

There have been a number of papers which have had similar ideas.


\section{Manual Query Syntax}

EagerDB has its own easy to use syntax for manually specifying preloads. Behind this manual query syntax is the idea that any query $Y$ can be used as an indicator for a later query $X$. Thus, if the probability of $X$ occurring is high given that $Y$ has occurred, then one should preload $X$ by bringing it into the database's cache. We call $Y$ the \emph{match statement}, and $X$ the \emph{preload statement}.

\subsection{Basic Definitions}

In order to explain match and preload statements more, we need to make a distinction between non-binded and binded SQL queries. A \emph{binded SQL query} is just any instance of a valid SQL statement which contains table, column, and attribute values. An example of a binded SQL query would be:

\begin{lstlisting}
SELECT * FROM distributors WHERE name = 'walmart' AND
  town = 'Chicago' AND state = 'IL'
\end{lstlisting}

A \emph{non-binded SQL query} is just an instance of a valid SQL statement which contains table and column values, but does not contain attribute values. For example, the non-binded version of the previous SQL query would be:

\begin{lstlisting}
SELECT * FROM distributors WHERE name = ? AND
  town = ? AND state = ?
\end{lstlisting}

Non-binded SQL queries can be converted into binded SQL queries by providing \emph{bind values}, an array of values which would be inserted into each bind location (denoted by a $?$ in the non-binded SQL query). To convert the previous non-binded SQL statement into a binded SQL statement, one would need to pass in the following array of bind values:

\begin{lstlisting}
['walmart', 'IL']
\end{lstlisting}

\subsection{Match Preload Files}

Match and preload statements are non-binded SQL queries. Match statements allow EagerDB to match on a particular SQL statement structure, and preload statements allow us to preload a specific SQL statement structure when match statements occur. In this vein, one could manually specify match and preload statements. This is done by first specifying a single match statement, then any number of preload statements to load into the cache whenever that match statement is seen.

In a \emph{match preload file} (MP file), a developer using EagerDB can specify a list of match statements and their corresponding preload statements. EagerDB can read over an MP file and incorporate any match and preload statements that have been made inside the file. A developer can use the MP file as a stand-alone product without running the Markov model so that the preload statements in the MP file will be the only statements preloaded by EagerDB, or incorporate the MP file as an addition on top of the Markov model's statements. The syntax for an MP file is straightforward:

\begin{itemize}
  \item Match statements are preceded by a dash ``-''.
  \item Preload statements are preceded by a rocket ``=\textgreater''. Preload statements will be paired with the last match statement seen in the MP file.
  \item SQL statements are encapsulated by quotation marks.
  \item Bind values, separated by commas, follow the SQL statement. The $i^{\textrm{th}}$ bind value in the SQL statement corresponds to the $i^{\textrm{th}}$ comma separated value after the SQL statement.
\end{itemize}

In addition to these syntax rules, there are methods provided for bind values which allow making general preload statements much easier. We provide the \texttt{match\_result} and \texttt{match\_bind\_value} keywords.

The \texttt{match\_result} keyword provides access to the result of the match statement of a preload. One can access the value of a column in the result by asking for the column name like so: \texttt{match\_result.column\_name}. For example, if a developer wanted to access the id of the result from his match statement, he could write a preload statement like so:

\begin{lstlisting}
=> "SELECT * FROM things WHERE product_id = ?", match_result.id
\end{lstlisting}

The \texttt{match\_bind\_value} keyword is a similar construction, but provides access to the bind value of the binded instance of the match statement. One specifies an index $i$ after the \texttt{match\_bind\_value} keyword, which gives access to the $i$th bind value from the match statement. For example, one could write:

\begin{lstlisting}
- "SELECT * FROM products WHERE name = ?"
  => "SELECT * FROM things WHERE product_name = ?", match_bind_value(0)
\end{lstlisting}

In the above, whenever of a SQL query of the form \texttt{SELECT * FROM products WHERE name = ?} is seen, EagerDB will take the zeroth bind value (bind values are indexed by 0) from the statement and use it as the first bind value in the preload statement \texttt{SELECT * FROM things WHERE product\_name = ?}.

\begin{figure}[h]
\begin{lstlisting}[frame=single]
- "SELECT * FROM users WHERE name = ?"
  => "SELECT * FROM products WHERE owner_id = ?",
      match_result.id

- "SELECT * FROM pinterest WHERE pin = ? AND interest = ?"
  => "SELECT * FROM tables WHERE pin = ? AND interest = ?",
      match_bind_value(0), match_bind_value(1)
  => "SELECT * FROM interests WHERE interest = ? AND
      pinterest_id = ?", match_bind_value(1), match_result.id
\end{lstlisting}
  \caption{\label{fig:mp-file-example}A snippet from an MP file}
\end{figure}

Figure \ref{fig:mp-file-example} provides an example instance of an MP file. In this file, there are two match statements. The first match statement has a single preload, while the second match statement has two preloads. EagerDB will listen to the stream of SQL queries coming from the database, and whenever a match statement matches the structure of a query, the preload statements associated with that match statement will be brought into the database's cache.

For example, using the MP file from figure \ref{fig:mp-file-example}, suppose the following sequence of queries arrived at the database (ordered chronologically):

\begin{lstlisting}
SELECT * FROM products WHERE name = 'table' AND state = 'IL'
SELECT * FROM users WHERE name = 'john'
SELECT * FROM laptops WHERE BRAND = 'lenovo' AND serial_number = '5'
\end{lstlisting}

Then, after the second query (\texttt{SELECT * FROM users WHERE name = 'john'}) was run, its corresponding preload statement would be brought into the cache. For example, if the second query returned a result with an id of 52, then the following query would be brought into the database's cache: \texttt{SELECT * FROM products WHERE owner\_id = 52}. The other queries in the sequence did not match the structure of any of the match statements, so EagerDB would not bring anything into the cache after their execution.

\section{System Design}

The EagerDB system is designed to be as unobstrusive as possible. It sits at the middleware level and only needs two things: 1) a connection to the stream of SQL queries and results being sent to and from the database and 2) a connection to the database for preloading queries. As a Ruby gem, EagerDB requires a minimal amount of integration and can be incorporated into a Ruby on Rails web application with less than 15 lines of code.

The system is also designed to be distributed and scalable. The EagerDB system is easily extended to multiple machines and can still be used with a sharded database. More details of the design later in the paper will show how this can be accomplished without any changes to the framework.

EagerDB is designed for flexibility, since it works on any database with a built-in cache, including MySQL, PostgreSQL, etc. It is SQL syntax agnostic, meaning that small variations in the syntax between different databases will not prevent EagerDB from preloading queries. This quality comes about because of the non-binded vs. binded SQL abstraction: all match statements are non-binded and general. In fact, EagerDB could potentially preload NoSQL queries, such as those from MongoDB, without any problems.

Additionally, EagerDB uses the database's own cache. This greatly simplfies setup and reduces the number of failure points. Instead of providing its own cache, which would have to deal with cache invalidation issues as well as duplication of data, EagerDB can rely on the pre-built mechanisms of the database. Thus, the design is resistant to bloating memory, and a user can tweak the size and properties of a single cache (instead of two). Moreover, using the database's own cache means that EagerDB can be used on more than just web applications. Since it has no appliction-specific logic, EagerDB can be used for anything that sends sends queries to a database.

Finally, EagerDB internally reads data from the MP file format, which enables a developer to change automatically generated preloads and provide their own preloads relatively easily. Having a single format for representing data greatly simplifies the amount of work a developer needs to do to make changes to their own preloads.

In order to accomplish all of the above traits, EagerDB makes a number of abstractions which will be presented in this section. The codebase is written in Ruby (so that it can conveniently be used in Ruby on Rails web applications) and is broken up into two sections. The first is the processing code, which provides the infrastructure for parsing MP files and running EagerDB with a live stream of queries, and the second is the prediction code, which creates a Markov model and outputs an MP file based on historical database logs.

\subsection{Processing Code}

In the processing code, the fundamental object of computation is called a processor.

\section{Conclusion}

Future directions of research include adding metadata to queries, figuring out match result issues with schemas.

\end{document}
